# 并发

## 一、概述

并发是指在同一时间内，存在多个任务同时执行的情况。对于多核设备，这些任务可能同时在不同CPU上并发执行。对于单核设备，多个并发任务不会在同一时刻并发执行，但是CPU会在某个任务休眠或进行I/O操作等状态下切换任务，调度执行其他任务，提升CPU的资源利用率。

为了提升应用的响应速度和帧率，避免耗时任务队UI主线程的影响，ArkTS提供了异步并发和多线程并发两种处理策略。

- ·异步并发是指异步代码在执行到一定程度后会被暂停，一边在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。ArkTS通过Primise和async/awiat提供异步并发能力，适用于单词I/O任务的开发场景。
- 多线程并发允许在同一时间段内同时执行多段代码。在UI主线程继续相应用户操作和更新UI的同时，后台线程也能执行耗时操作，从而避免应用出现卡顿。ArkT通过TaskPool和Worker提供多线程并发能力，适用于耗时任务等并发场景。

并发多线程场景下，不同并发线程间需要进行数据通信，不同类别对象的传输方式存在差异，包括拷贝或内存共享等。

并发能力在多种场景中都有应用，其中包括异步并发任务、耗时任务（CPU密集任务、I/O密集型任务和同步任务等）、长时任务、常驻任务等。可以根据不同的任务诉求和场景，选择相应的并发策略进行优化。

## 二、异步并发（Promise和async/await）

### 2.1 Promise

Promise是一种处理异步操作的对象，可以将异步操作转换为类似于同步操作的风格，一边代码编写和维护。Promise提供了一个状态机制来管理异步操作的不同阶段，并提供了一些方法来注册回调函数以处理异步操作的成功或失败的结果。

Promise有三种状态:pending(进行中)、fulfilled(已完成)、rejected(已拒绝)。Promise对象创建后处于pending状态，并在异步操作完成后转换为fulfilled或rejected状态

最基本的用法就是他哦那个过构造函数实例化一个Promise对象，同时传入一个带有两个参数的函数，通常称为executor函数。excutor函数接收两个参数:resolve和reject，分别表示异步操作成功和失败时的回调函数。例如，一下代码创建了一个Promise对象并模拟了一个异步操作:

```typescript
const promise: Promise<number> = new Promise((resolve: Function, reject: Function) => {
setTimeout(() => {
  const randomNumber: number = Math.random();
  if (randomNumber > 0.5) {
    resolve(randomNumber);
  } else {
    reject(new Error('Random number is too small'));
  }
}, 1000);
})
```

上述代码中，setTimeout函数模拟了一个异步操作，并在1秒钟后随机生成一个数字。如果随机数大于0.5，则执行resolve回调函数并将随机数作为参数传递；否则执行reject回调函数并传递一个错误对象作为参数。

Promise对象创建后，可以使用then方法和catch方法指定fulfilled状态和rejected状态的回调函数。then方法可接受两个参数，一个处理fulfilled状态的函数，另一个处理rejected状态的函数。只传一个参数则表示当Promise对象状态变为fulfilled时，then方法会自动调用这个回调函数，并将Promise对象的结果作为参数传递给它。使用catch方法注册一个回调函数，用于处理“失败”的结果，即捕获Promise的状态改变为rejected状态或操作失败抛出的异常。例如：

```typescript
import { BusinessError } from '@kit.BasicServicesKit';

promise.then((result: number) => {
 console.info(`Random number is ${result}`);
}).catch((error: BusinessError) => {
 console.error(error.message);
});
```

上述代码中，then方法的回调函数接收Promise对象的成功结果作为参数，并将其输出到控制台上。如果Promise对象进入rejected状态，则catch方法的回调函数接收错误对象作为参数，并将其输出到控制台上。

> **说明**
>
> 当Promise被reject且未通过catch方法来处理时，会触发unhandledrejection事件。可使用errorManager.on('error')接口监听该事件，以全局捕获未处理的Promise reject。

### 2.2 async/await

async/await是一种用于处理异步操作的Promise语法糖，使得编写异步代码变得更加简单和易读。通过使用async关键字声明一个函数为异步函数，并使用await关键字等待Promise的解析（完成或拒绝），以同步的方式编写异步操作的代码。

async函数是一个返回Promise对象的函数，用于表示一个异步操作。在async函数内部，可以使用await关键字等待一个Promise对象的解析，并返回其解析值。

> 注意，这里只是等待对象的解析，而**不会堵塞UI线程**
>
> ArkTS 运行于单线程环境，采用事件循环机制。该机制允许单线程高效处理多个任务。主线程有一个任务队列，事件循环会不断从队列里取出任务并执行。
>
> 当 `await` 暂停 `async` 函数的执行时，事件循环会继续处理其他任务。一旦 `Promise` 被解决，对应的回调函数会被放入任务队列，等待事件循环取出并执行。这样，UI 进程就能继续响应用户的操作，不会被阻塞。

如果一个async函数抛出异常，那么该函数返回的Promise对象将被拒绝，并且异常信息会被传递给Promise对象的onRejected()方法。

下面是一个使用async/await的例子，其中模拟了一个以同步方式执行异步操作的场景，该操作会在3秒钟后返回一个字符串。

```typescript
async function myAsyncFunction(): Promise<string> {
  const result: string = await new Promise((resolve: Function) => {
    setTimeout(() => {
      resolve('Hello, world!');
    }, 3000);
  });
  console.info(result); // 输出： Hello, world!
  return result;
}

@Entry
@Component
struct Index {
  @State message: string = 'Hello World';
  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(async () => {
            let res = await myAsyncFunction();
            console.info("res is: " + res);
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

在上述示例代码中，使用了await关键字来等待Promise对象的解析，并将其解析值存储在result变量中。

需要注意的是，由于要等待异步操作完成，因此需要将整个操作包在async函数中，并搭配await关键字使用。除了在async函数中使用await外，还可以使用try/catch块来捕获异步操作中的异常。

```typescript
async function myAsyncFunction(): Promise<void> {
  try {
    const result: string = await new Promise((resolve: Function) => {
      resolve('Hello, world!');
    });
  } catch (e) {
    console.error(`Get exception: ${e}`);
  }
}

myAsyncFunction();
```

### 2.3 事件循环



## 三、多线程并发

### 3.1 多线程并发概述

并发模型是用来实现不同应用场景中并发任务的编程模型，常见的并发模型分为基于内存共享的并发模型和基于消息通信的并发模型。

Actor并发模型作为基于消息通信并发模型的典型代表，不需要开发者去面对锁带来的一系列复杂偶发的问题，同时并发度也相对较高，因此得到了广泛的支持和使用。

当前ArkTS提供了TaskPool和Worker两种并发能力，TaskPool和Worker都基于Actor并发模型实现。

### 3.2 **多线程并发模型**

内存共享并发模型指多线程同时执行任务，这些线程依赖同一内存并且都有权限访问，线程访问内存前需要抢占并锁定内存的使用劝，没有抢占到内存的线程需要等待其他线程释放使用权再执行。

Actor并发模型每一个线程都是一个独立Actor，每个Actor有自己独立的内存，Actor之间通过消息传递机制触发对方Actor行为，不同Actor之间不能直接访问对方的内存空间。

由于Actor并发模型线程之间不共享内存，需要通过线程间通信机制传输并发任务和任务结果。

**内存共享模型**

内存共享模型指多线程同时执行任务，这些线程依赖同一内存并且都有权限访问，线程访问内存前需要抢占并锁定内存的使用权，没有抢占到内存的线程需要等待其他线程释放使用权再执行。同一时间只能有一个生产者或消费者访问该容器，也就是不同生产者和消费者争夺使用容器的锁。当一个角色获取锁之后其他角色需要等待该角色释放锁之后才能重新尝试获取锁以访问该容器。

![0000000000011111111.20250314170230.11205329479566227709476607208807:50001231000000:2800:F5794CAC525A26D7C19D7D75045BB1490C6E822AD33CC94AA6D35A44954E8154.png](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170230.11205329479566227709476607208807:50001231000000:2800:F5794CAC525A26D7C19D7D75045BB1490C6E822AD33CC94AA6D35A44954E8154.png)

**Actor模型**

Actor模型不同角色之间并不共享内存，生产者线程和UI线程都有自己的虚拟机实例，两个虚拟机实例之间拥有独占的内存，相互隔离。生产者生产出结果后通过序列化通信将结果发送给UI线程，UI线程消费结果后再发送新的生产任务给生产者线程。

Actor并发模型对比内存共享并发模型的优势在于不同线程间内存隔离，不会产生不同线程竞争同一内存资源的问题。开发者不需要考虑对内存上锁导致的一系列功能、性能问题，提升了开发效率。

![0000000000011111111.20250314170230.76279357139754768299685059759587:50001231000000:2800:001796039BEF10561775B2DC8281ADC1A226DE15DF8ECC420E506509EB22124A.png](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170230.76279357139754768299685059759587:50001231000000:2800:001796039BEF10561775B2DC8281ADC1A226DE15DF8ECC420E506509EB22124A.png)

### 3.3 TaskPool简介

任务池（TaskPool）作用是为应用程序提供一个多线程的运行环境，降低整体资源的消耗、提高系统的整体性能，且您无需关心线程实例的生命周期。

**TaskPook运作机制**

![0000000000011111111.20250314170230.22872154019692151545901864356681:50001231000000:2800:4B8FB30085AB4AAAD63041CE8643886A1029E11BF399C49D39C2CD4E3A62398B.png](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170230.22872154019692151545901864356681:50001231000000:2800:4B8FB30085AB4AAAD63041CE8643886A1029E11BF399C49D39C2CD4E3A62398B.png)

TaskPool支持开发者在宿主线程封装任务抛给任务队列，系统选择合适的工作线程，进行任务的分发及执行，再将结果返回给宿主线程。接口直观易用，支持任务的执行、取消，以及指定优先级的能力，同时通过系统统一线程管理，结合动态调度及负载均衡算法，可以节约系统资源。系统默认会启动一个任务工作线程，当任务较多时会扩容，工作线程数量上限跟当前设备的物理核数相关，具体数量内部管理，保证最优的调度及执行效率，长时间没有任务分发时会缩容，减少工作线程数量。

**TaskPool注意事项**

- 实现任务的函数需要使用@Concurrent装饰器标注，且仅支持在.ets文件中使用。
- 从API version 11开始，跨并发实例传递带方法的实例对象时，该类必须使用装饰器@Sendable装饰器标注，且仅支持在.ets文件中使用。
- 任务函数在TaskPool工作线程的执行耗时不能超过3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时），否则会被强制退出。
- 实现任务的函数入参需满足序列化支持的类型
- ArrayBuffer参数在TaskPool中默认转移，需要设置转移列表的话可通过接口setTransferList()设置。
- 由于不同线程中上下文对象是不同的，因此TaskPool工作线程只能使用线程安全的库，例如UI相关的非线程安全库不能使用。
- 序列化传输的数据量大小限制为16MB。
- Priority的IDLE优先级是用来标记需要在后台运行的耗时任务（例如数据同步、备份），它的优先级别是最低的。这种优先级标记的任务只会在所有线程都空闲的情况下触发执行，并且只会占用一个线程来执行。
- Promise不支持跨线程传递，如果TaskPool返回pending或rejected状态的Promise，会返回失败；对于fulfilled状态的Promise，TaskPool会解析返回的结果，如果结果可以跨线程传递，则返回成功。
- 不支持在TaskPool工作线程中使用AppStorage。
- TaskPool支持开发者在宿主线程封装任务抛给任务队列，理论上可以支持任意多的任务，但任务的执行受限于任务的优先级以及系统资源的影响，在工作线程扩容到最大后，可能会导致任务的执行效率下降。

**说明**

由于@Concurrent标记的函数不能访问闭包，因此@Concurrent标记的函数内部不能调用当前文件的其他函数，例如：

```typescript
function bar() {
}

@Concurrent
function foo() {
bar(); // 违反闭包原则，报错
}
```

### 3.4 Worker简介

Worker主要作用是为应用程序提供一个多线程的运行环境，可满足应用程序在执行过程中与宿主线程分离，在后台线程中运行一个脚本进行耗时操作，极大避免类似于计算密集型或高延迟的任务阻塞宿主线程的运行。

**Worker运作机制**

![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170231.30610609115110537440495482226210:50001231000000:2800:0F9434615602A1B439A61D8509E58F0C6E7655AE4C6F0F258FCF6C381372BD7D.png)

创建Worker的线程称为宿主线程（不一定是主线程，工作线程也支持创建Worker子线程），Worker自身的线程称为Worker子线程（或Actor线程、工作线程）。每个Worker子线程与宿主线程拥有独立的实例，包含基础设施、对象、代码段等，因此每个Worker启动存在一定的内存开销，需要限制Worker的子线程数量。Worker子线程和宿主线程之间的通信是基于消息传递的，Worker通过序列化机制与宿主线程之间相互通信，完成命令及数据交互。

#### **Woker注意事项**

- 创建Worker时，有手动和自动两种创建方式，手动创建Worker线程目录及文件时，还需同步进行相关配置，。
- 使用Worker能力时，构造函数中传入的Worker线程文件的路径在不同版本有不同的规则。
- Worker创建后需要手动管理生命周期，且最多同时运行的Worker子线程数量为64个。
- 由于不同线程中上下文对象是不同的，因此Worker线程只能使用线程安全的库，例如UI相关的非线程安全库不能使用。
- 序列化传输的数据量大小限制为16MB。
- 使用Worker模块时，需要在宿主线程中注册onerror接口，否则当Worker线程出现异常时会发生jscrash问题。
- 不支持跨HAP使用Worker线程文件。
- 引用HAR/HSP前，需要先配置对HAR/HSP的依赖。
- 不支持在Worker工作线程中使用AppStorage。

**创建Worker的注意事项**

Worker线程文件需要放在"{moduleName}/src/main/ets/"目录层级之下，否则不会被打包到应用中。有手动和自动两种创建Worker线程目录及文件的方式。

- 手动创建：开发者手动创建相关目录及文件，此时需要配置build-profile.json5的相关字段信息，Worker线程文件才能确保被打包到应用中。

  Stage模型：

  ```json
  "buildOption": {
    "sourceOption": {
      "workers": [
        "./src/main/ets/workers/worker.ets"
      ]
    }
  }
  ```

  FA模型：

  ```json
  "buildOption": {
    "sourceOption": {
      "workers": [
        "./src/main/ets/MainAbility/workers/worker.ets"
      ]
    }
  }
  ```

- 自动创建：DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，点击鼠标右键 > New > Worker，即可自动生成Worker的模板文件及配置信息，无需再手动在build-profile.json5中进行相关配置。

**文件路径注意事项**

当使用Worker模块具体功能时，均需先构造Worker实例对象，其构造函数与API版本相关，且构造函数需要传入Worker线程文件的路径（scriptURL）。

```typescript
// 导入模块
import { worker } from '@kit.ArkTS';

// API 9及之后版本使用：
const worker1: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/worker.ets');
// API 8及之前版本使用：
const worker2: worker.Worker = new worker.Worker('entry/ets/workers/worker.ets');
```

**Stage模型下的文件路径规则**

构造函数中的scriptURL要求如下：

- scriptURL的组成包含 {moduleName}/ets 和相对路径 relativePath。
- relativePath是Worker线程文件相对于"{moduleName}/src/main/ets/"目录的相对路径。

1） 加载Ability中Worker线程文件场景

加载Ability中的worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。

```typescript
import { worker } from '@kit.ArkTS';

// worker线程文件所在路径："entry/src/main/ets/workers/worker.ets"
const workerStage1: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/worker.ets');

// worker线程文件所在路径："testworkers/src/main/ets/ThreadFile/workers/worker.ets"
const workerStage2: worker.ThreadWorker = new worker.ThreadWorker('testworkers/ets/ThreadFile/workers/worker.ets');
```

2） 加载HSP中Worker线程文件场景

加载HSP中worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。

```typescript
import { worker } from '@kit.ArkTS';

// worker线程文件所在路径： "hsp/src/main/ets/workers/worker.ets"
const workerStage3: worker.ThreadWorker = new worker.ThreadWorker('hsp/ets/workers/worker.ets');
```

3） 加载HAR中Worker线程文件场景

加载HAR中worker线程文件存在以下两种情况：

- @标识路径加载形式：所有种类的模块加载本地HAR中的Worker线程文件，加载路径规则：@{moduleName}/ets/{relativePath}。
- 相对路径加载形式：本地HAR加载该包内的Worker线程文件，加载路径规则：创建Worker对象所在文件与Worker线程文件的相对路径。

**说明**

当开启useNormalizedOHMUrl（即将工程目录中与entry同级别的应用级build-profile.json5文件中strictMode属性的useNormalizedOHMUrl字段配置为true）或HAR包会被打包成三方包使用时，则HAR包中使用Worker仅支持通过相对路径的加载形式创建。

```typescript
import { worker } from '@kit.ArkTS';

// @标识路径加载形式：
// worker线程文件所在路径: "har/src/main/ets/workers/worker.ets"
const workerStage4: worker.ThreadWorker = new worker.ThreadWorker('@har/ets/workers/worker.ets');

// 相对路径加载形式：
// worker线程文件所在路径: "har/src/main/ets/workers/worker.ets"
// 创建Worker对象的文件所在路径："har/src/main/ets/components/mainpage/MainPage.ets"
const workerStage5: worker.ThreadWorker = new worker.ThreadWorker('../../workers/worker.ets');
```

**FA模型下的文件路径规则**

构造函数中的scriptURL为：Worker线程文件与"{moduleName}/src/main/ets/MainAbility"的相对路径。

```typescript
import { worker } from '@kit.ArkTS';

// 主要说明以下三种场景：

// 场景1： Worker线程文件所在路径："{moduleName}/src/main/ets/MainAbility/workers/worker.ets"
const workerFA1: worker.ThreadWorker = new worker.ThreadWorker("workers/worker.ets", {name:"first worker in FA model"});

// 场景2： Worker线程文件所在路径："{moduleName}/src/main/ets/workers/worker.ets"
const workerFA2: worker.ThreadWorker = new worker.ThreadWorker("../workers/worker.ets");

// 场景3： Worker线程文件所在路径："{moduleName}/src/main/ets/MainAbility/ThreadFile/workers/worker.ets"
const workerFA3: worker.ThreadWorker = new worker.ThreadWorker("ThreadFile/workers/worker.ets");
```

**生命周期注意事项**

- Worker的创建和销毁耗费性能，建议开发者合理管理已创建的Worker并重复使用。Worker空闲时也会一直运行，因此当不需要Worker时，可以调用terminate()]接口或close()方法主动销毁Worker。若Worker处于已销毁或正在销毁等非运行状态时，调用其功能接口，会抛出相应的错误。
- Worker的数量由内存管理策略决定，设定的内存阈值为1.5GB和设备物理内存的60%中的较小者。在内存允许的情况下，系统最多可以同时运行64个Worker。如果尝试创建的Worker数量超出这一上限，系统将抛出错误：“Worker initialization failure, the number of workers exceeds the maximum.”。实际运行的Worker数量会根据当前内存使用情况动态调整。一旦所有Worker和主线程的累积内存占用超过了设定的阈值，系统将触发内存溢出（OOM）错误，导致应用程序崩溃。

#### Woker基本用法示例

1. DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，点击鼠标右键 > New > Worker，即可自动生成Worker的模板文件及配置信息。本文以创建“worker”为例。

2. 导入Worker模块。

   ```typescript
   // Index.ets
   import { ErrorEvent, MessageEvents, worker } from '@kit.ArkTS'
   ```

   

3. 在宿主线程中通过调用ThreadWorker的constructor()方法创建Worker对象，当前线程为宿主线程，并注册回调函数。

   ```typescript
   // Index.ets
   @Entry
   @Component
   struct Index {
     @State message: string = 'Hello World';
   
     build() {
       RelativeContainer() {
         Text(this.message)
           .id('HelloWorld')
           .fontSize(50)
           .fontWeight(FontWeight.Bold)
           .alignRules({
             center: { anchor: '__container__', align: VerticalAlign.Center },
             middle: { anchor: '__container__', align: HorizontalAlign.Center }
           })
           .onClick(() => {
             // 创建Worker对象
             let workerInstance = new worker.ThreadWorker('entry/ets/workers/worker.ets');
   
             // 注册onmessage回调，当宿主线程接收到来自其创建的Worker通过workerPort.postMessage接口发送的消息时被调用，在宿主线程执行
             workerInstance.onmessage = (e: MessageEvents) => {
               let data: string = e.data;
               console.info("workerInstance onmessage is: ", data);
             }
   
             // 注册onerror回调，当Worker在执行过程中发生异常时被调用，在宿主线程执行
             workerInstance.onerror = (err: ErrorEvent) => {
               console.info("workerInstance onerror message is: " + err.message);
             }
   
             // 注册onmessageerror回调，当Worker对象接收到一条无法被序列化的消息时被调用，在宿主线程执行
             workerInstance.onmessageerror = () => {
               console.info('workerInstance onmessageerror');
             }
   
             // 注册onexit回调，当Worker销毁时被调用，在宿主线程执行
             workerInstance.onexit = (e: number) => {
               // 当Worker正常退出时code为0，异常退出时code为1
               console.info("workerInstance onexit code is: ", e);
             }
   
             // 向Worker线程发送消息
             workerInstance.postMessage('1');
           })
       }
       .height('100%')
       .width('100%')
     }
   }
   ```

4. 在Worker文件中注册回调函数。

   ```typescript
   // worker.ets
   import { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';
   
   const workerPort: ThreadWorkerGlobalScope = worker.workerPort;
   
   // 注册onmessage回调，当Worker线程收到来自其宿主线程通过postMessage接口发送的消息时被调用，在Worker线程执行
   workerPort.onmessage = (e: MessageEvents) => {
     let data: string = e.data;
     console.info('workerPort onmessage is: ', data);
   
     // 向主线程发送消息
     workerPort.postMessage('2');
   }
   
   // 注册onmessageerror回调，当Worker对象接收到一条无法被序列化的消息时被调用，在Worker线程执行
   workerPort.onmessageerror = () => {
     console.info('workerPort onmessageerror');
   }
   
   // 注册onerror回调，当Worker在执行过程中发生异常被调用，在Worker线程执行
   workerPort.onerror = (err: ErrorEvent) => {
     console.info('workerPort onerror err is: ', err.message);
   }
   ```

### 3.5 TaskPool和Worker的对比

TaskPool（任务池）和Worker的作用是为应用程序提供一个多线程的运行环境，用于处理耗时的计算任务或其他密集型任务。可以有效地避免这些任务阻塞宿主线程，从而最大化系统的利用率，降低整体资源消耗，并提高系统的整体性能。

#### 实现特点对比

| 实现             | TaskPool                                                     | Worker                                                       |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 内存模型         | 线程间隔离，内存不共享。                                     | 线程间隔离，内存不共享。                                     |
| 参数传递机制     | 采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。支持ArrayBuffer转移和SharedArrayBuffer共享。 | 采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。支持ArrayBuffer转移和SharedArrayBuffer共享。 |
| 参数传递         | 直接传递，无需封装，默认进行transfer。                       | 消息对象唯一参数，需要自己封装。                             |
| 方法调用         | 直接将方法传入调用。                                         | 在Worker线程中进行消息解析并调用对应方法。                   |
| 返回值           | 异步调用后默认返回。                                         | 主动发送消息，需在onmessage解析赋值。                        |
| 生命周期         | TaskPool自行管理生命周期，无需关心任务负载高低。             | 开发者自行管理Worker的数量及生命周期。                       |
| 任务池个数上限   | 自动管理，无需配置。                                         | 同个进程下，最多支持同时开启64个Worker线程，实际数量由进程内存决定。 |
| 任务执行时长上限 | 3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时），长时任务无执行时长上限。 | 无限制。                                                     |
| 设置任务的优先级 | 支持配置任务优先级。                                         | 不支持。                                                     |
| 执行任务的取消   | 支持取消已经发起的任务。                                     | 不支持。                                                     |
| 线程复用         | 支持。                                                       | 不支持。                                                     |
| 任务延时执行     | 支持。                                                       | 不支持。                                                     |
| 设置任务依赖关系 | 支持。                                                       | 不支持。                                                     |
| 串行队列         | 支持。                                                       | 不支持。                                                     |
| 任务组           | 支持。                                                       | 不支持。                                                     |

#### 适用场景对比

由于TaskPool的工作线程会绑定系统的调度优先级，并且支持负载均衡（自动扩缩容），而Worker需要开发者自行创建，存在创建耗时以及不支持设置调度优先级，故在性能方面使用TaskPool会优于Worker，因此大多数场景推荐使用TaskPool。

常见的一些开发场景及适用具体说明如下：

- 运行时间超过3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时）的任务。例如后台进行1小时的预测算法训练等CPU密集型任务，需要使用Worker。
- 有关联的一系列同步任务。例如在一些需要创建、使用句柄的场景中，句柄创建每次都是不同的，该句柄需永久保存，保证使用该句柄进行操作，需要使用Worker。
- 需要设置优先级的任务。例如图库直方图绘制场景，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，需要使用TaskPool。
- 需要频繁取消的任务。例如图库大图浏览场景，为提升体验，会同时缓存当前图片左右侧各2张图片，往一侧滑动跳到下一张图片时，要取消另一侧的一个缓存任务，需要使用TaskPool。
- 大量或者调度点较分散的任务。例如大型应用的多个模块包含多个耗时任务，不方便使用Worker去做负载管理，推荐采用TaskPool。
- 对于需要频繁数据库操作的场景，由于读写数据库存在耗时，因此推荐在子线程中操作，避免阻塞UI线程，推荐使用TaskPool。

## 四、并发线程间通信

线程间通信指的是并发多线程间存在的数据交换行为。

对于不同的数据对象，在ArkTS线程间通信的行为是有差异的，比如普通JS对象、ArrayBuffer对象、SharedArrayBuffer对象等，跨线程的行为是不一致的，包括序列化反序列化拷贝、数据转移、数据共享等不同行为。

以JS对象为例，其在并发任务间的通信采用了标准的Structure Clone算法（序列化反序列化），通过序列化将JS对象转成与引擎无关的数据（字符串或内存块等），在另一个并发实例通过反序列化，还原成与原JS对象内容一致的新对象，因此通常需要经过深拷贝，效率较低。

ArkTS目前主要提供两种并发能力支持线程间通信：TaskPool和Worker。

- Worker是Actor并发模型标准的跨线程通信API，与Web Worker或者Node.js Worker的使用方式基本一致。
- TaskPool提供了功能更强、并发编程更简易的任务池API。其中TaskPool涉及跨并发实例的对象传递行为与Worker一致，还是采用了标准的Structured Clone算法，并发通信的对象越大，耗时就越长。

### 4.1 线程间通信对象

#### 4.1.1 **普通对象**

普通对象跨线程时通过拷贝形式传递，两个线程的对象内容一致，但是指向各自线程的隔离内存区间，被分配在各自线程的虚拟机本地堆（LocalHeap）。

![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170231.19645765597291215706686267652548:50001231000000:2800:89B5958928C5FE05131FE5E97EC69700686D8C65B229527F10A3F9656E5D2B0A.png)

> 说明
>
> 普通类实例对象跨线程通过拷贝形式传递，只能传递数据，类实例上的方法会丢失。可以使用@Sendable装饰器标识为Sendable类，类实例对象跨线程传递后，可携带类方法。

#### 4.1.2 **ArrayBuufer对象**

ArrayBuffer内部包含一块Native内存，该ArrayBuffer的JS对象壳被分配在虚拟机本地堆（LocalHeap）。与普通对象一样，需要经过序列化与反序列化拷贝传递，但是Native内存有两种传输方式：拷贝和转移。

**传输时采用拷贝**的话，需要经过深拷贝（递归遍历），传输后两个线程都可以独立访问ArrayBuffer。通信过程如下图所示：

![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170231.56414194003720486227783260020446:50001231000000:2800:20CCFDFE8B62D146B342681AAA823A05D7780F464772296472091BC2D7D1C18E.png)

**如果采用转移**的方式，则原线程无法使用此ArrayBuffer对象，跨线程时只需重建JS壳，Native内存无需拷贝，效率更高。通信过程如下图所示：

![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170231.40594296014992194402484648603255:50001231000000:2800:E0C940D9B87D44F77EC208F5B8FB639D7796A8840DD7087DF48CEF62C51DD2D6.png)

ArrayBuffer可以用来表示图片等资源，在应用开发中，会遇到需要进行图片处理的场景（比如需要调整一张图片的亮度、饱和度、大小等），为了避免阻塞UI主线程，可以将图片传递到子线程中执行这些操作。转移方式性能更高，但是原线程不能再访问ArrayBuffer对象，如果两个线程都需要访问，则需要采用拷贝方式，否则建议采用转移方式，提升性能。

#### 4.1.3 SharedArrayBuffer对象

SharedArrayBuffer内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。支持跨并发实例间共享，但是访问及修改需要采用Atomics类，防止数据竞争。SharedArrayBuffer可以用于多个并发实例间的状态共享或者数据共享。通信过程如下图所示：

![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170231.64757822499961364997829917275118:50001231000000:2800:97615663C8B8CF6C48B4A200FCAEE83474A756449B678C709963569919D9BC3E.png)

#### 4.1.4 Transferable对象（NativeBinding对象）

Transferable对象（也称为NativeBinding对象）指的是一个JS对象，绑定了一个C++对象，且主体功能由C++提供，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。跨线程传输时可以直接复用同一个C++对象，相比于JS对象的拷贝模式，传输效率较高。因此，可共享或转移的NativeBinding对象也被称为Transferable对象。

**共享模式**

如果C++实现能够保证线程安全性，则这个NativeBinding对象的C++部分可以支持共享传输。此时，NativeBinding对象跨线程传输后，只需要重新创建JS壳，就可以桥接到相同的C++对象上。通信过程如下图所示：

![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170231.26669041651302077469969241484861:50001231000000:2800:945C3901EFF7A281F790313E1D85FED02ADD4FBE1B0318C77668696BDBA9340B.png)

常见的共享模式NativeBinding对象包括Context，Context对象包含应用程序组件的上下文信息，它提供了一种访问系统服务和资源的方式，使得应用程序组件可以与系统进行交互。

**转移模式**

如果C++实现包含了数据，且无法保证线程安全性，则这个NativeBinding对象的C++部分需要采用转移方式传输。此时，NativeBinding对象跨线程传输后，只需要重新创建JS壳，就可以桥接到C++对象上，不过原对象需要移除对此对象的绑定关系。通信过程如下图所示：

![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170231.83161844108144055563949634709044:50001231000000:2800:1C1A11C2E650561FB66BF8597B74E211043290AF704E9B1DB08DD1D1DCF36CD9.png)

#### 4.1.5 Sendable对象

##### 简介

Sendable对象为可共享的，其跨线程前后指向同一个JS对象，如果其包含了JS或者Native内容，均可以直接共享，如果底层是Native实现的，则需要考虑线程安全性。通信过程如下图所示：

![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170232.80636722682008485561906678362593:50001231000000:2800:01809A63A9ECEAC9E85DD162B9A2677DB9290C3219AFE8E7AD80AAAFA3851591.png)

与其它ArkTS对象不一样的是，符合Sendable协议的数据对象在运行时必须是类型固定的对象。

**实现原理**

当多个并发实例尝试同时更新Sendable数据时，会发生数据竞争，例如ArkTS共享容器的多线程操作。因此，ArkTS提供了异步锁的机制来避免不同并发实例间的数据竞争。同时，还可以通过对象冻结接口冻结对象，将其变为只读对象，就可以不用考虑数据的竞争问题。

Sendable对象提供了并发实例间高效的通信效率，即引用传递的能力，一般适用于开发者自定义大对象需要线程间通信的场景，例如子线程读取数据库的数据返回宿主线程。

![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170232.43747853943848763477821903450128:50001231000000:2800:D5D6BDC4C1F7C332228F0B57C6934133E450F6E77B6682D40539B4A7386DD41E.png)

##### 异步锁

为了解决多线程并发任务间的数据竞争问题，ArkTS引入了异步锁能力。由于ArkTS语言支持异步操作，阻塞锁容易产生死锁问题，因此在ArkTS中仅支持异步锁（非阻塞式锁）

##### ASON解析与生成

SON则提供了Sendable对象的序列化、反序列化能力。可以通过ASON.stringify方法将对象转换成字符串，也可以通过ASON.parse方法将字符串转成Sendable对象，以便此对象在并发任务间进行高性能引用传递。

> 说明
>
> ASON.parse默认生成的对象为Sendable对象，布局不可变，不支持增删属性。如果需要支持返回对象的布局可变，可以指定返回类型为MAP，此时会全部返回collections.Map对象，支持增删属性。

##### 共享容器

ArkTS共享容器是一种在并发任务间共享传输的容器类，可以用于并发场景下的高性能数据传递。ArkTS共享容器在多个并发任务间传递时，其默认行为是引用传递，支持多个并发任务可以操作同一个容器实例。另外，也支持拷贝传递，即每个并发任务持有一个ArkTS容器实例。ArkTS共享容器并不是线程安全的，内部使用了fail-fast（快速失败）机制，即当检测多个并发实例同时对容器进行结构性改变时，会触发异常。

##### 共享模块

共享模块是进程内只会加载一次的模块，使用"use shared"这一指令来标记一个模块是否为共享模块。

非共享模块在同一线程内只加载一次，在不同线程间会加载多次，在不同的线程内都会产生新的模块对象。因此可以使用共享模块来实现进程单例。

##### Sendable对象冻结

Sendable对象支持冻结操作，冻结后的对象变成只读对象，不能增删改属性，因此在多个并发实例间访问均不需要加锁，可以通过调用Object.freeze接口冻结对象。

### 4.2 线程间通信场景

#### 4.2.1 使用TaskPool执行独立的耗时任务

对于一个独立运行的耗时任务，只需要在任务执行完毕后将结果返回给宿主线程，没有上下文依赖，可以通过以下方式实现。

**加载图片**

1. 实现子线程需要执行的任务。

   ```typescript
   // IconItemSource.ets
   export class IconItemSource {
     image: string | Resource = '';
     text: string | Resource = '';
   
     constructor(image: string | Resource = '', text: string | Resource = '') {
       this.image = image;
       this.text = text;
     }
   }
   ```

   ```typescript
   // IndependentTask.ets
   import { IconItemSource } from './IconItemSource';
    
   // 在Task中执行的方法，需要添加@Concurrent注解，否则无法正常调用。
   @Concurrent
   export function loadPicture(count: number): IconItemSource[] {
     let iconItemSourceList: IconItemSource[] = [];
     // 遍历添加6*count个IconItem的数据
     for (let index = 0; index < count; index++) {
       const numStart: number = index * 6;
       // 此处循环使用6张图片资源
       iconItemSourceList.push(new IconItemSource('$media:startIcon', `item${numStart + 1}`));
       iconItemSourceList.push(new IconItemSource('$media:background', `item${numStart + 2}`));
       iconItemSourceList.push(new IconItemSource('$media:foreground', `item${numStart + 3}`));
       iconItemSourceList.push(new IconItemSource('$media:startIcon', `item${numStart + 4}`));
       iconItemSourceList.push(new IconItemSource('$media:background', `item${numStart + 5}`));
       iconItemSourceList.push(new IconItemSource('$media:foreground', `item${numStart + 6}`));
     }
     return iconItemSourceList;
   }
   ```

2. 通过TaskPool中的execute方法执行上述任务，即加载图片。

   ```typescript
   // Index.ets
   import { taskpool } from '@kit.ArkTS';
   import { IconItemSource } from './IconItemSource';
   import { loadPicture } from './IndependentTask';
   
   @Entry
   @Component
   struct Index {
     @State message: string = 'Hello World';
   
     build() {
       Row() {
         Column() {
           Text(this.message)
             .fontSize(50)
             .fontWeight(FontWeight.Bold)
             .onClick(() => {
               let iconItemSourceList: IconItemSource[] = [];
               // 创建Task
               let lodePictureTask: taskpool.Task = new taskpool.Task(loadPicture, 30);
               // 执行Task，并返回结果
               taskpool.execute(lodePictureTask).then((res: object) => {
                 // loadPicture方法的执行结果
                 iconItemSourceList = res as IconItemSource[];
               })
             })
         }
         .width('100%')
       }
       .height('100%')
     }
   }
   ```

#### 4.2.2 使用TaskPool执行多个耗时任务

如果有多个任务同时执行，由于任务的复杂度不同，执行时间会不一样，返回数据的时间也是不可控的。如果宿主线程需要所有任务执行完毕的数据，那么可以通过下面这种方式实现。

除此以外，如果需要处理的数据量较大（比如一个列表中有10000条数据），把这些数据都放在一个Task中处理也是比较耗时的。那么就可以将原始数据拆分成多个列表，并将每个子列表分配给一个独立的Task进行执行，并且等待全部执行完毕后拼成完整的数据，这样可以节省处理时间，提升用户体验。

**多个任务进行图片加载**

1. 实现子线程需要执行的任务。

   ```typescript
   // IconItemSource.ets
   export class IconItemSource {
     image: string | Resource = '';
     text: string | Resource = '';
   
     constructor(image: string | Resource = '', text: string | Resource = '') {
       this.image = image;
       this.text = text;
     }
   }
   ```

   ```typescript
   // IndependentTask.ets
   import { IconItemSource } from './IconItemSource';
    
   // 在Task中执行的方法，需要添加@Concurrent注解，否则无法正常调用。
   @Concurrent
   export function loadPicture(count: number): IconItemSource[] {
     let iconItemSourceList: IconItemSource[] = [];
     // 遍历添加6*count个IconItem的数据
     for (let index = 0; index < count; index++) {
       const numStart: number = index * 6;
       // 此处循环使用6张图片资源
       iconItemSourceList.push(new IconItemSource('$media:startIcon', `item${numStart + 1}`));
       iconItemSourceList.push(new IconItemSource('$media:background', `item${numStart + 2}`));
       iconItemSourceList.push(new IconItemSource('$media:foreground', `item${numStart + 3}`));
       iconItemSourceList.push(new IconItemSource('$media:startIcon', `item${numStart + 4}`));
       iconItemSourceList.push(new IconItemSource('$media:background', `item${numStart + 5}`));
       iconItemSourceList.push(new IconItemSource('$media:foreground', `item${numStart + 6}`));
   
     }
     return iconItemSourceList;
   }
   ```

2. 将需要执行的Task放到了一个TaskGroup里面，当TaskGroup中所有的Task都执行完毕后，会把每个Task运行的结果都放在一个数组中返回到宿主线程，而不是每执行完一个Task就返回一次，这样就可以在返回的数据里拿到所有的Task执行结果，方便宿主线程使用。

   ```typescript
   // MultiTask.ets
   import { taskpool } from '@kit.ArkTS';
   import { IconItemSource } from './IconItemSource';
   import { loadPicture } from './IndependentTask';
    
   let iconItemSourceList: IconItemSource[][];
    
   let taskGroup: taskpool.TaskGroup = new taskpool.TaskGroup();
   taskGroup.addTask(new taskpool.Task(loadPicture, 30));
   taskGroup.addTask(new taskpool.Task(loadPicture, 20));
   taskGroup.addTask(new taskpool.Task(loadPicture, 10));
   taskpool.execute(taskGroup).then((ret: object) => {
     let tmpLength = (ret as IconItemSource[][]).length
     for (let i = 0; i < tmpLength; i++) {
       for (let j = 0; j < ret[i].length; j++) {
         iconItemSourceList.push(ret[i][j]);
       }
     }
   })
   ```

#### 4.2.3 TaskPool任务与宿主线程通信

如果一个Task，不仅需要返回最后的执行结果，而且需要定时通知宿主线程状态、数据的变化，或者需要分段返回数量级较大的数据（比如从数据库中读取大量数据），可以通过下面这种方式实现。

**多个图片加载任务结果实时返回**

1. 首先，实现一个方法，用来接收Task发送的消息。

   ```typescript
   // TaskSendDataUsage.ets
   function notice(data: number): void {
     console.info("子线程任务已执行完，共加载图片: ", data);
   }
   ```

2. 然后，在Task需要执行的任务中，添加sendData()接口将消息发送给宿主线程。

   ```typescript
   // IconItemSource.ets
   export class IconItemSource {
     image: string | Resource = '';
     text: string | Resource = '';
   
     constructor(image: string | Resource = '', text: string | Resource = '') {
       this.image = image;
       this.text = text;
     }
   }
   ```

   ```typescript
   // TaskSendDataUsage.ets
   import { taskpool } from '@kit.ArkTS';
   import { IconItemSource } from './IconItemSource';
   
   // 通过Task的sendData方法，即时通知宿主线程信息
   @Concurrent
   export function loadPictureSendData(count: number): IconItemSource[] {
     let iconItemSourceList: IconItemSource[] = [];
     // 遍历添加6*count个IconItem的数据
     for (let index = 0; index < count; index++) {
       const numStart: number = index * 6;
       // 此处循环使用6张图片资源
       iconItemSourceList.push(new IconItemSource('$media:startIcon', `item${numStart + 1}`));
       iconItemSourceList.push(new IconItemSource('$media:background', `item${numStart + 2}`));
       iconItemSourceList.push(new IconItemSource('$media:foreground', `item${numStart + 3}`));
       iconItemSourceList.push(new IconItemSource('$media:startIcon', `item${numStart + 4}`));
       iconItemSourceList.push(new IconItemSource('$media:background', `item${numStart + 5}`));
       iconItemSourceList.push(new IconItemSource('$media:foreground', `item${numStart + 6}`));
   
       taskpool.Task.sendData(iconItemSourceList.length);
     }
     return iconItemSourceList;
   }
   ```

3. 最后，在宿主线程通过onReceiveData()接口接收消息。

   这样宿主线程就可以通过notice()接口接收到Task发送的数据。

   ```typescript
   // TaskSendDataUsage.ets
   @Entry
   @Component
   struct Index {
     @State message: string = 'Hello World';
   
     build() {
       Row() {
         Column() {
           Text(this.message)
             .fontSize(50)
             .fontWeight(FontWeight.Bold)
             .onClick(() => {
               let iconItemSourceList: IconItemSource[];
               let lodePictureTask: taskpool.Task = new taskpool.Task(loadPictureSendData, 30);
               // 设置notice方法接收Task发送的消息
               lodePictureTask.onReceiveData(notice);
               taskpool.execute(lodePictureTask).then((res: object) => {
                 iconItemSourceList = res as IconItemSource[];
               })
             })
         }
         .width('100%')
       }
       .height('100%')
     }
   }
   ```

#### 4.2.4 Worker和宿主线程的即时消息通信

在ArkTS中，Worker相对于Taskpool存在一定的差异性，有数量限制但是可以长时间存在。一个Worker中可能会执行多个不同的任务，每个任务执行的时长或者返回的结果可能都不相同，宿主线程需要根据情况调用Worker中的不同方法，Worker则需要及时地将结果返回给宿主线程。

**Worker响应"hello world"请求**

1. 首先，创建一个执行多个任务Worker。

   ```typescript
   // Worker.ets
   import { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';
   
   const workerPort: ThreadWorkerGlobalScope = worker.workerPort;
   // Worker接收宿主线程的消息，做相应的处理
   workerPort.onmessage = (e: MessageEvents): void => {
     if (e.data === 'hello world') {
       workerPort.postMessage('success');
     }
   }
   ```

2. 这里的宿主线程为UI主线程，在宿主线程中创建这个Worker的对象，在点击Button的时候调用postmessage向Worker发送消息，通过Worker的onmessage方法接收Worker返回的数据。

   ```typescript
   // Index.ets
   import { worker } from '@kit.ArkTS';
   import { BusinessError } from '@kit.BasicServicesKit';
   
   function promiseCase() {
     let p: Promise<void> = new Promise<void>((resolve: Function, reject: Function) => {
       setTimeout(() => {
         resolve(1);
       }, 100)
     }).then(undefined, (error: BusinessError) => {
     })
     return p;
   }
   
   async function postMessageTest() {
     let ss = new worker.ThreadWorker("entry/ets/workers/Worker.ets");
     let res = undefined;
     let flag = false;
     let isTerminate = false;
     ss.onexit = () => {
       isTerminate = true;
     }
     // 接收Worker线程发送的消息
     ss.onmessage = (e) => {
       res = e.data;
       flag = true;
       console.info("worker:: res is  " + res);
     }
     // 给Worker线程发送消息
     ss.postMessage("hello world");
     while (!flag) {
       await promiseCase();
     }
   
     ss.terminate();
     while (!isTerminate) {
       await promiseCase();
     }
   }
   
   @Entry
   @Component
   struct Index {
     @State message: string = 'Hello World';
     build() {
       Row() {
         Column() {
           Text(this.message)
             .fontSize(50)
             .fontWeight(FontWeight.Bold)
             .onClick(() => {
               postMessageTest();
             })
         }
         .width('100%')
       }
       .height('100%')
     }
   }
   ```

#### 4.2.5 Worker同步调用宿主线程的接口

如果一个接口在主线程中已经实现了，Worker需要调用该接口，那么可以使用下面这种方式实现。

1. 首先，在宿主线程实现需要调用的接口，并且创建Worker对象，在Worker上注册需要调用的接口。

   ```typescript
   // IconItemSource.ets
   export class IconItemSource {
     image: string | Resource = '';
     text: string | Resource = '';
   
     constructor(image: string | Resource = '', text: string | Resource = '') {
       this.image = image;
       this.text = text;
     }
   }
   ```

   ```typescript
   // WorkerCallGlobalUsage.ets
   import worker from '@ohos.worker';
   import { IconItemSource } from './IconItemSource';
   
   // 创建Worker对象
   const workerInstance: worker.ThreadWorker = new worker.ThreadWorker("entry/ets/pages/workers/Worker.ts");
   
   class PicData {
     public iconItemSourceList: IconItemSource[] = [];
   
     public setUp(): string {
       for (let index = 0; index < 20; index++) {
         const numStart: number = index * 6;
         // 此处循环使用6张图片资源
         this.iconItemSourceList.push(new IconItemSource('$media:startIcon', `item${numStart + 1}`));
         this.iconItemSourceList.push(new IconItemSource('$media:background', `item${numStart + 2}`));
         this.iconItemSourceList.push(new IconItemSource('$media:foreground', `item${numStart + 3}`));
         this.iconItemSourceList.push(new IconItemSource('$media:startIcon', `item${numStart + 4}`));
         this.iconItemSourceList.push(new IconItemSource('$media:background', `item${numStart + 5}`));
         this.iconItemSourceList.push(new IconItemSource('$media:foreground', `item${numStart + 6}`));
   
       }
       return "setUpIconItemSourceList success!";
     }
   }
   
   let picData = new PicData();
   // 在Worker上注册需要调用的对象
   workerInstance.registerGlobalCallObject("picData", picData);
   workerInstance.postMessage("run setUp in picData");
   ```

2. 然后，在Worker中通过callGlobalCallObjectMethod接口就可以调用宿主线程中的setUp()方法了。

   ```typescript
   // Worker.ets
   import { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';
   const workerPort: ThreadWorkerGlobalScope = worker.workerPort;
   try {
     // 调用方法无入参
     let res: string = workerPort.callGlobalCallObjectMethod("picData", "setUp", 0) as string;
     console.error("worker: ", res);
   } catch (error) {
     // 异常处理
     console.error("worker: error code is " + error.code + " error message is " + error.message);
   }
   ```

## 五、应用多线程开发概述

针对常见的业务场景，主要可以对应分为三种并发任务：

- **耗时任务**：业务逻辑包含较大计算量或多次I/O读写等需要长时间执行的任务（CPU密集型任务、I/O密集型任务以及同步任务）。
- **长时任务**：业务逻辑包含监听或定期采集数据等需要长时间保持运行的任务。
- **常驻任务**：业务逻辑跟随主线程生命周期或与主线程绑定的任务

### 5.1 耗时任务并发场景

耗时任务指的是需要长时间执行的任务，如果在UI主线程执行可能导致应用卡顿掉帧、响应慢等问题。典型的耗时任务有CPU密集型任务、I/O密集型任务以及同步任务。

对应耗时任务，常见的业务场景分类如下所示：

| 常见业务场景    | 具体业务描述                                                 | CPU密集型 | I/O密集型 | 同步任务 |
| :-------------- | :----------------------------------------------------------- | :-------- | :-------- | :------- |
| 图片/视频编解码 | 将图片或视频进行编解码再展示。                               | √         | √         | ×        |
| 压缩/解压缩     | 对本地压缩包进行解压操作或者对本地文件进行压缩操作。         | √         | √         | ×        |
| JSON解析        | 对JSON字符串的序列化和反序列化操作。                         | √         | ×         | ×        |
| 模型运算        | 对数据进行模型运算分析等。                                   | √         | ×         | ×        |
| 网络下载        | 密集网络请求下载资源、图片、文件等。                         | ×         | √         | ×        |
| 数据库操作      | 将聊天记录、页面布局信息、音乐列表信息等保存到数据库，或者应用二次启动时，读取数据库展示相关信息。 | ×         | √         | ×        |

#### 5.1.1 CPU密集型任务

CPU密集型任务是指需要占用系统资源处理大量计算能力的任务，需要长时间运行，这段时间会阻塞线程其它事件的处理，不适宜放在UI主线程进行。例如图像处理、视频编码、数据分析等。

基于多线程并发机制处理CPU密集型任务可以提高CPU利用率，提升应用程序响应速度。

当任务不需要长时间（3分钟）占据后台线程，而是一个个独立的任务时，推荐使用TaskPool，反之推荐使用Worker。

接下来将以图像直方图处理以及后台长时间的模型预测任务分别进行举例。

**使用TaskPool进行图像直方图处理**

CPU密集型任务是指需要占用系统资源处理大量计算能力的任务，需要长时间运行，这段时间会阻塞线程其它事件的处理，不适宜放在UI主线程进行。例如图像处理、视频编码、数据分析等。

基于多线程并发机制处理CPU密集型任务可以提高CPU利用率，提升应用程序响应速度。

当任务不需要长时间（3分钟）占据后台线程，而是一个个独立的任务时，推荐使用TaskPool，反之推荐使用Worker。

接下来将以图像直方图处理以及后台长时间的模型预测任务分别进行举例。

1. 实现图像处理的业务逻辑。

2. 数据分段，通过任务组发起关联任务调度。

   创建TaskGroup]并通过addTask()添加对应的任务，通过execute()执行任务组，并指定为高优先级，在当前任务组所有任务结束后，会将直方图处理结果同时返回。

3. 结果数组汇总处理。

```typescript
import { taskpool } from '@kit.ArkTS';

@Concurrent
function imageProcessing(dataSlice: ArrayBuffer): ArrayBuffer {
  // 步骤1: 具体的图像处理操作及其他耗时操作
  return dataSlice;
}

function histogramStatistic(pixelBuffer: ArrayBuffer): void {
  // 步骤2: 分成三段并发调度
  let number: number = pixelBuffer.byteLength / 3;
  let buffer1: ArrayBuffer = pixelBuffer.slice(0, number);
  let buffer2: ArrayBuffer = pixelBuffer.slice(number, number * 2);
  let buffer3: ArrayBuffer = pixelBuffer.slice(number * 2);

  let group: taskpool.TaskGroup = new taskpool.TaskGroup();
  group.addTask(imageProcessing, buffer1);
  group.addTask(imageProcessing, buffer2);
  group.addTask(imageProcessing, buffer3);

  taskpool.execute(group, taskpool.Priority.HIGH).then((ret: Object) => {
    // 步骤3: 结果数组汇总处理
  })
}

@Entry
@Component
struct Index {
  @State message: string = 'Hello World'

  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(() => {
            let buffer: ArrayBuffer = new ArrayBuffer(24);
            histogramStatistic(buffer);
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

**使用Worker进行长时间数据分析**

本文通过某地区提供的房价数据训练一个简易的房价预测模型，该模型支持通过输入房屋面积和房间数量去预测该区域的房价，模型需要长时间运行，房价预测需要使用前面的模型运行结果，因此需要使用Worker。

1. DevEco Studio提供了Worker创建的模板，新建一个Worker线程，例如命名为“MyWorker”。

   ![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250314170233.81535343531071044664222807145104:50001231000000:2800:92028063850225158FC551E6DC262C154B34CCA988DD0BCBF29B5C48E74F2073.png)

2. 在宿主线程中通过调用ThreadWorker的constructor()方法创建Worker对象。

   ```typescript
   // Index.ets
   import { worker } from '@kit.ArkTS';
   
   const workerInstance: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/MyWorker.ts');
   ```

3. 在宿主线程中通过调用onmessage()]方法接收Worker线程发送过来的消息，并通过调用postMessage()]方法向Worker线程发送消息。

   例如向Worker线程发送训练和预测的消息，同时接收Worker线程发送回来的消息。

   ```typescript
   // Index.ets
   let done = false;
   
   // 接收Worker子线程的结果
   workerInstance.onmessage = (() => {
     console.info('MyWorker.ts onmessage');
     if (!done) {
       workerInstance.postMessage({ 'type': 1, 'value': 0 });
       done = true;
     }
   })
   
   workerInstance.onerror = (() => {
     // 接收Worker子线程的错误信息
   })
   
   // 向Worker子线程发送训练消息
   workerInstance.postMessage({ 'type': 0 });
   ```

4. 在MyWorker.ts文件中绑定Worker对象，当前线程为Worker线程。

   ```typescript
   // MyWorker.ts
   import { worker, ThreadWorkerGlobalScope, MessageEvents, ErrorEvent } from '@kit.ArkTS';
   
   let workerPort: ThreadWorkerGlobalScope = worker.workerPort;
   ```

5. 在Worker线程中通过调用onmessage()方法接收宿主线程发送的消息内容，并通过调用postMessage()方法向宿主线程发送消息。

   例如在Worker线程中定义预测模型及其训练过程，同时与宿主线程进行信息交互。

   ```typescript
   // MyWorker.ts
   // 定义训练模型及结果
   let result: Array<number>;
   // 定义预测函数
   function predict(x: number): number {
    return result[x];
   }
   // 定义优化器训练过程
   function optimize(): void {
    result = [0];
   }
   // Worker线程的onmessage逻辑
   workerPort.onmessage = (e: MessageEvents): void => {
    // 根据传输的数据的type选择进行操作
    switch (e.data.type as number) {
     case 0:
     // 进行训练
      optimize();
     // 训练之后发送宿主线程训练成功的消息
      workerPort.postMessage({ type: 'message', value: 'train success.' });
      break;
     case 1:
     // 执行预测
      const output: number = predict(e.data.value as number);
     // 发送宿主线程预测的结果
      workerPort.postMessage({ type: 'predict', value: output });
      break;
     default:
      workerPort.postMessage({ type: 'message', value: 'send message is invalid' });
      break;
    }
   }
   ```

6. 在Worker线程中完成任务之后，执行Worker线程销毁操作。销毁线程的方式主要有两种：根据需要可以在宿主线程中对Worker线程进行销毁；也可以在Worker线程中主动销毁Worker线程。

   在宿主线程中通过调用[onexit()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V14/js-apis-worker-V14#onexit9)方法定义Worker线程销毁后的处理逻辑。

   ```typescript
   // Worker线程销毁后，执行onexit回调方法
   workerInstance.onexit = (): void => {
    console.info("main thread terminate");
   }
   ```

   方式一：在宿主线程中通过调用[terminate()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V14/js-apis-worker-V14#terminate9)方法销毁Worker线程，并终止Worker接收消息。

   ```typescript
   // 销毁Worker线程
   workerInstance.terminate();
   ```

   方式二：在Worker线程中通过调用[close()](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V14/js-apis-worker-V14#close9)方法主动销毁Worker线程，并终止Worker接收消息。

   ```typescript
   // 销毁线程
   workerPort.close();
   ```

#### 5.1.2 I/O密集型任务

使用异步并发可以解决单次I/O任务阻塞的问题，但是如果遇到I/O密集型任务，同样会阻塞线程中其它任务的执行，这时需要使用多线程并发能力来进行解决。

I/O密集型任务的性能重点通常不在于CPU的处理能力，而在于I/O操作的速度和效率。这种任务通常需要频繁地进行磁盘读写、网络通信等操作。此处以频繁读写系统文件来模拟I/O密集型并发任务的处理。

1. 定义并发函数，内部密集调用I/O能力。

   ```typescript
   // write.ets
   import { fileIo } from '@kit.CoreFileKit'
   
   // 定义并发函数，内部密集调用I/O能力
   // 写入文件的实现
   export async function write(data: string, filePath: string): Promise<void> {
     let file: fileIo.File = await fileIo.open(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
     await fileIo.write(file.fd, data);
     fileIo.close(file);
   }
   ```

   ```typescript
   // Index.ets
   import { write } from './write'
   import { BusinessError } from '@kit.BasicServicesKit';
   import { taskpool } from '@kit.ArkTS';
   import { common } from '@kit.AbilityKit';
   
   @Concurrent
   async function concurrentTest(context: common.UIAbilityContext): Promise<boolean> {
     let filePath1: string = context.filesDir + "/path1.txt"; // 应用文件路径
     let filePath2: string = context.filesDir + "/path2.txt";
     // 循环写文件操作
     let fileList: Array<string> = [];
     fileList.push(filePath1);
     fileList.push(filePath2)
     for (let i: number = 0; i < fileList.length; i++) {
       write('Hello World!', fileList[i]).then(() => {
         console.info(`Succeeded in writing the file. FileList: ${fileList[i]}`);
       }).catch((err: BusinessError) => {
         console.error(`Failed to write the file. Code is ${err.code}, message is ${err.message}`)
         return false;
       })
     }
     return true;
   }
   ```

2. 使用TaskPool执行包含密集I/O的并发函数：通过调用execute()方法执行任务，并在回调中进行调度结果处理。

   ```typescript
   // Index.ets
   @Entry
   @Component
   struct Index {
     @State message: string = 'Hello World';
     build() {
       Row() {
         Column() {
           Text(this.message)
             .fontSize(50)
             .fontWeight(FontWeight.Bold)
             .onClick(() => {
               let context = getContext() as common.UIAbilityContext;
   
               // 使用TaskPool执行包含密集I/O的并发函数
               // 数组较大时，I/O密集型任务任务分发也会抢占UI主线程，需要使用多线程能力
               taskpool.execute(concurrentTest, context).then(() => {
                 // 调度结果处理
                 console.info("taskpool: execute success")
               })
             })
         }
         .width('100%')
       }
       .height('100%')
     }
   }
   ```

#### 5.1.3 同步任务

同步任务是指在多个线程之间协调执行的任务，其目的是确保多个任务按照一定的顺序和规则执行，例如使用锁来防止数据竞争。

同步任务的实现需要考虑多个线程之间的协作和同步，以确保数据的正确性和程序的正确执行。

由于TaskPool偏向于单个独立的任务，因此当各个同步任务之间相对独立时推荐使用TaskPool，例如一系列导入的静态方法，或者单例实现的方法。如果同步任务之间有关联性，则需要使用Worker，例如无法单例创建的类对象实现的方法。

**使用TaskPool处理同步任务**

当调度独立的任务，或者一系列任务为静态方法实现，或者可以通过单例构造唯一的句柄或类对象，可在不同任务线程之间使用时，推荐使用TaskPool。

> 说明
>
> 由于Actor模型不同线程间内存隔离的特性，普通单例无法在不同线程间使用。可以通过共享模块导出单例解决该问题。

1. 定义并发函数，实现业务逻辑。
2. 创建任务Task，通过execute()接口执行该任务。
3. 对任务返回的结果进行操作。

```typescript
// Index.ets代码
import { taskpool} from '@kit.ArkTS';

// 步骤1: 定义并发函数，实现业务逻辑
@Concurrent
async function taskpoolFunc(num: number): Promise<number> {
  // 根据业务逻辑实现相应的功能
  let tmpNum: number = num + 100;
  return tmpNum;
}

async function mainFunc(): Promise<void> {
  // 步骤2: 创建任务并执行
  let task1: taskpool.Task = new taskpool.Task(taskpoolFunc, 1);
  let res1: number = await taskpool.execute(task1) as number;
  let task2: taskpool.Task = new taskpool.Task(taskpoolFunc, res1);
  let res2: number = await taskpool.execute(task2) as number;
  // 步骤3: 对任务返回的结果进行操作
  console.info("taskpool: task res1 is: " + res1);
  console.info("taskpool: task res2 is: " + res2);
}

@Entry
@Component
struct Index {
  @State message: string = 'Hello World';

  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(async () => {
            mainFunc();
          })
      }
      .width('100%')
      .height('100%')
    }
  }
}
```

**使用Worker处理关联的同步任务**

当一系列同步任务需要使用同一个句柄调度，或者需要依赖某个类对象调度，无法在不同任务池之间共享时，需要使用Worker。

1. 在UI主线程中创建Worker对象，同时接收Worker线程发送回来的消息。DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，点击鼠标右键 > New > Worker，即可自动生成Worker的模板文件及配置信息。

   ```typescript
   // Index.ets
   import { worker } from '@kit.ArkTS';
   
   @Entry
   @Component
   struct Index {
     @State message: string = 'Hello World';
   
     build() {
       Row() {
         Column() {
           Text(this.message)
             .fontSize(50)
             .fontWeight(FontWeight.Bold)
             .onClick(() => {
               let w: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/MyWorker.ts');
               w.onmessage = (): void => {
                 // 接收Worker子线程的结果
               }
               w.onerror = (): void => {
                 // 接收Worker子线程的错误信息
               }
               // 向Worker子线程发送Set消息
               w.postMessage({'type': 0, 'data': 'data'})
               // 向Worker子线程发送Get消息
               w.postMessage({'type': 1})
               // ...
               // 根据实际业务，选择时机以销毁线程
               w.terminate()
             })
         }
         .width('100%')
       }
       .height('100%')
     }
   }
   ```

2. 在Worker线程中绑定Worker对象，同时处理同步任务逻辑。

   ```typescript
   // handle.ts代码
   export default class Handle {
     syncGet() {
       return;
     }
   
     syncSet(num: number) {
       return;
     }
   }
   ```

   ```typescript
   // MyWorker.ts代码
   import { worker, ThreadWorkerGlobalScope, MessageEvents } from '@kit.ArkTS';
   import Handle from './handle';  // 返回句柄
   
   let workerPort : ThreadWorkerGlobalScope = worker.workerPort;
   
   // 无法传输的句柄，所有操作依赖此句柄
   let handler: Handle = new Handle()
   
   // Worker线程的onmessage逻辑
   workerPort.onmessage = (e : MessageEvents): void => {
    switch (e.data.type as number) {
     case 0:
      handler.syncSet(e.data.data);
      workerPort.postMessage('success set');
      break;
     case 1:
      handler.syncGet();
      workerPort.postMessage('success get');
      break;
    }
   }
   ```

### 5.2 长时任务并发场景

在应用业务实现过程中，对于需要较长时间不定时运行的任务，称为长时任务。长时任务如果放在UI主线程中执行会阻塞UI主线程的UI业务，出现卡顿丢帧等影响用户体验的问题。因此通常需要将这个独立的长时任务放到单独的子线程中执行。

典型的长时任务场景如下所示：

| 常见业务场景       | 具体业务描述                                                 |
| :----------------- | :----------------------------------------------------------- |
| 定期采集传感器数据 | 周期性采集一些传感器信息（例如位置信息、速度传感器等），应用运行阶段长时间不间断运行。 |
| 监听Socket端口信息 | 长时间监听Socket数据，不定时需要响应处理。                   |

上述业务场景均为独立的长时任务，任务执行周期长，跟外部交互简单，分发到后台线程后，需要不定期响应，以获取结果。这些类型的任务使用TaskPool可以简化开发工作量，避免管理复杂的生命周期，避免线程泛滥，开发者只需要将上述独立的长时任务放入TaskPool队列，再等待结果即可。

**使用TaskPool进行传感器数据监听**

1. 导入需要用到的模块。

   ```typescript
   // Index.ets
   import { sensor } from '@kit.SensorServiceKit';
   import { taskpool } from '@kit.ArkTS';
   import { BusinessError, emitter } from '@kit.BasicServicesKit';
   ```

2. 定义长时任务，内部监听sensor数据，并通过emitter注册销毁通知。

   ```typescript
   // Index.ets
   @Concurrent
   async function SensorListener() : Promise<void> {
     sensor.on(sensor.SensorId.ACCELEROMETER, (data) => {
       emitter.emit({ eventId: 0 }, { data: data });
     }, { interval: 1000000000 });
   
     emitter.on({ eventId: 1 }, () => {
       sensor.off(sensor.SensorId.ACCELEROMETER)
       emitter.off(1)
     })
   }
   ```

3. 宿主线程定义注册及销毁的行为。

   - 注册：发起长时任务，并通过emitter接收监听数据。
   - 销毁：发送取消传感器监听的事件，并结束长时任务。

   ```typescript
   // Index.ets
   @Entry
   @Component
   struct Index {
     sensorTask?: taskpool.LongTask
   
     build() {
       Column() {
         Text("Add listener")
           .id('HelloWorld')
           .fontSize(50)
           .fontWeight(FontWeight.Bold)
           .onClick(() => {
             this.sensorTask = new taskpool.LongTask(SensorListener);
             emitter.on({ eventId: 0 }, (data) => {
               // Do something here
               console.info(`Receive ACCELEROMETER data: {${data.data?.x}, ${data.data?.y}, ${data.data?.z}`);
             });
             taskpool.execute(this.sensorTask).then(() => {
               console.info("Add listener of ACCELEROMETER success");
             }).catch((e: BusinessError) => {
               // Process error
             })
           })
         Text("Delete listener")
           .id('HelloWorld')
           .fontSize(50)
           .fontWeight(FontWeight.Bold)
           .onClick(() => {
             emitter.emit({ eventId: 1 });
             emitter.off(0);
             if(this.sensorTask != undefined) {
               taskpool.terminateTask(this.sensorTask);
             } else {
               console.error("sensorTask is undefined.");
             }
           })
       }
       .height('100%')
       .width('100%')
     }
   }
   ```

### 5.3 常驻任务并发场景

在应用业务实现过程中，对于一些长耗时（大于3min）且并发量不大的常驻任务场景，使用Worker在后台线程中运行这些耗时逻辑，避免阻塞UI主线程而导致出现丢帧卡顿等影响用户体验性的问题 。

常驻任务是指相比于短时任务，时间更长的任务，可能跟UI主线程生命周期一致。相比于长时任务，常驻任务更倾向于跟线程绑定的任务，单次运行时间更长（比如超过3分钟）。

对应常驻任务，较为常见的业务场景如下：

| 常见业务场景   | 具体业务描述                                           |
| :------------- | :----------------------------------------------------- |
| 游戏中台场景   | 启动子线程作为游戏业务的主逻辑线程，UI线程只负责渲染。 |
| 长耗时任务场景 | 后台长时间的模型预测任务、或者硬件测试等。             |

1. DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，点击鼠标右键 > New > Worker，即可自动生成Worker的模板文件及配置信息。本文以创建“Worker”为例。

2. 导入Worker模块。

   ```typescript
   // Index.ets
   import { worker } from '@kit.ArkTS';
   ```

3. 在宿主线程中通过调用ThreadWorker的constructor()方法创建Worker对象，当前线程为宿主线程。

   ```typescript
   // Index.ets
   const workerInstance: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/Worker.ets');
   ```

4. 此处宿主线程为UI主线程，宿主线程发送'start'，开始执行某个长期运行的任务并接收子线程返回的相关消息。在不需要执行该任务时发送'stop'，停止该任务执行，该示例中10s后结束该任务。

   ```typescript
   // Index.ets
   
   @Entry
   @Component
   struct Index {
     build() {
       Column() {
         Text("Listener task")
           .id('HelloWorld')
           .fontSize(50)
           .fontWeight(FontWeight.Bold)
           .onClick(() => {
             workerInstance.postMessage({type: 'start'})
             workerInstance.onmessage = (event) => {
               console.info('UI主线程收到消息:', event.data);
             }
             // 10秒后停止worker
             setTimeout(() => {
               workerInstance.postMessage({ type: 'stop' });
             }, 10000);
           })
       }
       .height('100%')
       .width('100%')
     }
   }
   ```

5. 在Worker线程中当接受到宿主线程发送的消息为'start'时，开始执行某个长时间不定期运行的任务并实时返回消息给宿主线程。当接收到的消息为'stop'时结束该任务执行并返回相应消息给宿主线程。

   ```typescript
   // Worker.ets
   import { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';
   const workerPort: ThreadWorkerGlobalScope = worker.workerPort;
   let isRunning = false;
   workerPort.onmessage = (e: MessageEvents) => {
     const type = e.data.type as string;
     if (type === 'start') {
       if (!isRunning) {
         isRunning = true;
         // 开始常驻任务
         performTask();
       }
     } else if (type === 'stop') {
       isRunning = false;
       workerPort.close();  // 关闭Worker
     }
   }
   // 模拟常驻任务
   function performTask() {
     if (isRunning) {
       // 模拟某个长期运行的任务
       workerPort.postMessage('Worker is performing a task');
       // 1秒后再次执行任务
       setTimeout(performTask, 1000);
     }
     workerPort.postMessage('Worker is stop performing a task');
   }
   ```